# Story 3.3: Time Tracking per Task

## Status
Done

## Story
**As a** user,
**I want** to track time spent on each task,
**so that** I can measure my study/work sessions.

## Acceptance Criteria

| # | Critério |
|---|----------|
| AC1 | Botão play/pause em cada task card (hover reveal) |
| AC2 | Timer exibe tempo em formato MM:SS ou HH:MM:SS |
| AC3 | Apenas uma task pode ter timer ativo por vez |
| AC4 | Iniciar timer em nova task pausa a anterior automaticamente |
| AC5 | Timer continua mesmo se card não está visível |
| AC6 | Badge "● TRACKING" em task com timer ativo |
| AC7 | Tempo total persiste entre sessões |
| AC8 | Timer persiste se fechar/reabrir browser |
| AC9 | Botão reset (no card expandido) com confirmação |
| AC10 | Tempo exibido mesmo quando timer parado |

## Tasks / Subtasks

- [x] Task 1: Criar utilitários de tempo (AC2)
  - [x] Criar src/utils/time.ts
  - [x] formatTime(seconds): string - MM:SS ou HH:MM:SS
  - [x] calculateElapsedTime(timeSpent, timerStartedAt): number
- [x] Task 2: Criar hook useTimer (AC3, AC4, AC5)
  - [x] Criar src/hooks/useTimer.ts
  - [x] startTimer(taskId): inicia timer, para anterior
  - [x] stopTimer(): para timer atual
  - [x] Usar activeTimerTaskId do store
  - [x] Atualizar Task no database
- [x] Task 3: Criar componente TaskTimer (AC1, AC2, AC6, AC10)
  - [x] Criar src/components/Task/TaskTimer.tsx
  - [x] Exibir tempo formatado
  - [x] Botão play/pause
  - [x] Badge "● TRACKING" se ativo
  - [x] Atualizar display a cada segundo quando ativo
- [x] Task 4: Integrar TaskTimer no TaskCard (AC1)
  - [x] Adicionar TaskTimer ao TaskCard
  - [x] Play/pause visível no hover
  - [x] Tempo sempre visível se > 0
- [x] Task 5: Implementar persistência do timer (AC7, AC8)
  - [x] Task tem: timeSpent (total), timerStartedAt (timestamp)
  - [x] Ao iniciar: set timerStartedAt = Date.now()
  - [x] Ao parar: timeSpent += elapsed, timerStartedAt = null
  - [x] Ao abrir app: calcular tempo desde timerStartedAt
- [x] Task 6: Implementar reset timer (AC9)
  - [x] Botão reset no card expandido
  - [x] ConfirmDialog: "Reset timer to 0?"
  - [x] Zerar timeSpent e timerStartedAt
- [x] Task 7: Atualizar store para activeTimerTaskId (AC3, AC4)
  - [x] Verificar que store tem activeTimerTaskId
  - [x] startTimer atualiza activeTimerTaskId
  - [x] stopTimer limpa activeTimerTaskId
  - [x] Persistir no localStorage

## Dev Notes

### Timer Data Model (já definido em types)
```typescript
interface Task {
  // ...
  timeSpent: number;           // Total em segundos
  timerStartedAt: number | null; // Timestamp se ativo, null se parado
}
```

### Time Utilities (de architecture.md)
```typescript
// src/utils/time.ts
export const formatTime = (seconds: number): string => {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;

  const pad = (n: number) => n.toString().padStart(2, '0');

  if (hrs > 0) {
    return `${pad(hrs)}:${pad(mins)}:${pad(secs)}`;
  }
  return `${pad(mins)}:${pad(secs)}`;
};

export const calculateElapsedTime = (
  timeSpent: number,
  timerStartedAt: number | null
): number => {
  if (!timerStartedAt) return timeSpent;
  const elapsed = Math.floor((Date.now() - timerStartedAt) / 1000);
  return timeSpent + elapsed;
};
```

### useTimer Hook
```typescript
// src/hooks/useTimer.ts
export const useTimer = () => {
  const activeTimerTaskId = useAppStore(state => state.activeTimerTaskId);
  const setActiveTimerTaskId = useAppStore(state => state.startTimer);
  const clearActiveTimer = useAppStore(state => state.stopTimer);

  const startTimer = async (taskId: string) => {
    // Parar timer anterior se existir
    if (activeTimerTaskId && activeTimerTaskId !== taskId) {
      await stopTimerForTask(activeTimerTaskId);
    }

    // Iniciar novo timer
    await db.tasks.update(taskId, {
      timerStartedAt: Date.now(),
      updatedAt: Date.now(),
    });
    setActiveTimerTaskId(taskId);
  };

  const stopTimer = async () => {
    if (!activeTimerTaskId) return;
    await stopTimerForTask(activeTimerTaskId);
    clearActiveTimer();
  };

  const stopTimerForTask = async (taskId: string) => {
    const task = await db.tasks.get(taskId);
    if (task && task.timerStartedAt) {
      const elapsed = Math.floor((Date.now() - task.timerStartedAt) / 1000);
      await db.tasks.update(taskId, {
        timeSpent: task.timeSpent + elapsed,
        timerStartedAt: null,
        updatedAt: Date.now(),
      });
    }
  };

  return { startTimer, stopTimer, activeTimerTaskId };
};
```

### TaskTimer Component
```typescript
interface TaskTimerProps {
  task: Task;
}

export const TaskTimer = ({ task }: TaskTimerProps) => {
  const { startTimer, stopTimer, activeTimerTaskId } = useTimer();
  const [displayTime, setDisplayTime] = useState(0);
  const isActive = activeTimerTaskId === task.id;

  useEffect(() => {
    // Atualizar display a cada segundo se ativo
    if (isActive) {
      const interval = setInterval(() => {
        setDisplayTime(calculateElapsedTime(task.timeSpent, task.timerStartedAt));
      }, 1000);
      return () => clearInterval(interval);
    } else {
      setDisplayTime(task.timeSpent);
    }
  }, [isActive, task.timeSpent, task.timerStartedAt]);

  return (
    <div className="flex items-center gap-2">
      <button onClick={() => isActive ? stopTimer() : startTimer(task.id)}>
        {isActive ? '⏸' : '▶'}
      </button>
      <span>{formatTime(displayTime)}</span>
      {isActive && <span className="text-green-600 text-xs">● TRACKING</span>}
    </div>
  );
};
```

### Testing
- Play/pause funciona
- Timer conta corretamente
- Apenas 1 timer ativo por vez
- Badge "TRACKING" aparece
- Tempo persiste no refresh
- Reset funciona com confirmação

## Definition of Done
- [x] Play/pause funciona
- [x] Timer conta corretamente
- [x] Apenas 1 timer ativo por vez
- [x] Badge "TRACKING" aparece
- [x] Tempo persiste no refresh
- [x] Reset funciona com confirmação

## Story Points
5

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-31 | 0.1 | Story criada a partir do PRD | River (SM) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
N/A - Implementation completed without debugging issues

### Completion Notes List
- Created time utility functions for formatting and calculating elapsed time
- Implemented useTimer hook with single-timer-at-a-time logic
- Created TaskTimer component with play/pause, time display, and TRACKING badge
- Integrated TaskTimer into TaskCard (collapsed and expanded views)
- Reset functionality with confirmation dialog
- Timer persistence via timerStartedAt timestamp in database
- activeTimerTaskId persisted in localStorage via Zustand persist middleware

### File List
| File | Action | Description |
|------|--------|-------------|
| `src/utils/time.ts` | Created | Time formatting utilities (formatTime, calculateElapsedTime) |
| `src/hooks/useTimer.ts` | Created | Timer management hook (startTimer, stopTimer, resetTimer, toggleTimer) |
| `src/components/Task/TaskTimer.tsx` | Created | Timer UI component with play/pause, time display, TRACKING badge, reset button |
| `src/components/Task/TaskCard.tsx` | Modified | Integrated TaskTimer in collapsed and expanded views |

---

## QA Results
*To be filled by QA agent*
